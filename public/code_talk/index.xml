<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>码上杂谈 on tyza66的博客</title>
    <link>https://www.tyza66.top/code_talk/</link>
    <description>Recent content in 码上杂谈 on tyza66的博客</description>
    <generator>Hugo -- 0.155.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 30 Jan 2026 19:36:07 +0800</lastBuildDate>
    <atom:link href="https://www.tyza66.top/code_talk/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[码上杂谈][002期]“禅”已成过去式？“禅”并没有完全消失！</title>
      <link>https://www.tyza66.top/code_talk/c002/</link>
      <pubDate>Fri, 30 Jan 2026 19:36:07 +0800</pubDate>
      <guid>https://www.tyza66.top/code_talk/c002/</guid>
      <description>&lt;p&gt;　　“禅”（Zen）是一个曾经在技术界十分火爆的词汇，它有着这样几层含义：极简主义、专注与流动、直觉与顿悟、自然之道&amp;hellip; 这个词汇同时强调了简洁、高雅、顿悟、自然，简单来说就是一种巧思的模式和境界，正如这个字的宗教或哲学概念。&lt;/p&gt;
&lt;p&gt;　　比起零几年的时候，总觉得这些年生活的节奏越来越快，记得小时候晚上七八点钟全家都已经深度入睡了，几乎没有触及到十一二点的领域，当时电视和广播里面还会有一些关于午夜十二点的都市传说。不过现在觉得熬夜到十一二点已经是平常了，也许是娱乐方式更多了，也许是生活中要处理的事情多了，总之人们（可能只是我身边）总有理由睡得很晚。&lt;/p&gt;
&lt;p&gt;　　记得我2023年第一次到大连这座城市的时候，当时临时住在一个宾馆，对面是一个上面写着404的大厦，下午饿了去找吃的，走到了一个全是玻璃墙的大楼的一段落路上看见很多人，他们走的飞快，好像都非常着急。每个人都这样，无论男女老少，当时我是大四来大连实习，当时我就感叹，大城市的生活节奏是真快啊！后来又去北京工作、在杭州送过外卖，也总感觉世界变得快了，甚至有些地方有点快的过度了。&lt;/p&gt;
&lt;p&gt;　　“禅”的概念2020年代后其实就开始很少出现了，甚至让人产生了一种“禅”在技术圈已经消亡的错觉。这几天我在学校图书馆看到一本《CSS禅意花园》，我的第一想法其实是”CSS也能单独出一本书？这都不算一门编程语言了&amp;hellip;就是学前端顺带的事儿&amp;hellip;“，但我立刻反思了一下，曾经也许就是这样啊！过去的生活节奏慢，而且搜索方式匮乏，这种书其实十分有意义。一本《CSS禅意花园》，在今天也许显得“轻”，但在当时，它可能是前端开发者通往“美学与秩序”的一扇门，当年也许能给无数人带来启发和财富。况且曾经的技术人有更多时间去“体会”而不是“应付”。那时候的技术书籍，不只是教你怎么写代码，更是在传达一种思维方式、一种对世界的看法。也许曾经真的存在这样一个“慢时代”，并且这个时代曾留下了它的痕迹！&lt;/p&gt;
&lt;p&gt;　　随着云原生、AI、大数据等技术爆发，行业节奏越来越快，大家更关注“效率”和“落地”，而不是“哲思”和“美学”。“禅”这种慢思维、深思考的风格显得或许不太“接地气”。零零后后程序员更倾向于“工具主义”和“实用主义”，他们可能更喜欢“黑客精神”、“开源文化”、“AI驱动”等标签，而不是“禅意”、“顿悟”这种偏哲学的表达。过去大家追求极简架构、优雅代码，现在则更强调生态系统的整合能力，比如微服务、DevOps、平台化等，这些都需要复杂的协作和工具链，不再是一个人静静敲代码的“禅修”状态。&lt;/p&gt;
&lt;p&gt;　　但，“禅”已成过去式？其实“禅”并没有完全消失，而是悄悄地融入了其他领域！在产品设计中，它变成了“极简主义”。在用户体验中，它变成了“无感交互”、“沉浸式体验”。在工程文化中，它变成了“代码即禅”、“架构即道”。它不是被遗忘了，而是换了衣服，继续影响着技术世界。&lt;/p&gt;
&lt;p&gt;　　技术求索，才能突破。哲学追问，才能拓展。沉淀和巧思仍在开发世界占有不可或缺的地位。技术求索，不只是为了“掌握技能”，更是为了理解世界、塑造世界、甚至重新定义世界。哲学追问的意义，不在于“得到答案”，而在于“拓展视野”和“澄清本质”。尤其在技术、设计、创作这些领域，哲学追问往往是突破惯性思维的关键。&lt;/p&gt;
&lt;p&gt;　　现在的快节奏，有时让人感觉筋疲力尽，甚至有时候很想逃离。无论是生活中还是开发中，在这种“快节奏”灾害天气中，也许“禅”会成为我们的避风港。静下来进行一场奇思妙想的哲学追问，不断求索，努力找回那宁静的境界。技术如此，生活亦然。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[码上杂谈][001期]一道笔试题竟如此离谱！</title>
      <link>https://www.tyza66.top/code_talk/c001/</link>
      <pubDate>Tue, 08 Aug 2023 19:36:06 +0800</pubDate>
      <guid>https://www.tyza66.top/code_talk/c001/</guid>
      <description>&lt;h3 id=&#34;一起因&#34;&gt;一、起因&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最近是实习找工作季，很多同学都在参加各种各样的面试、笔试，我的一个同学在参加某公司的笔试时，遇到了一道很有意思的题目，我也是在他的分享中看到的这道题目。&lt;/li&gt;
&lt;li&gt;后来听说在这场笔试后，面试官看完答卷，就直接把答卷扔进了垃圾桶，宣布没有一个人答对。这让我感觉到了这道题目的离谱之处，所以我就想着写一篇文章来分享一下这道题目。&lt;/li&gt;
&lt;li&gt;小小一道写运行结果的题目，竟能把全场面试者难住，这道题目的出题者真的是太有才了。&lt;/li&gt;
&lt;li&gt;如果不仔细看的话，就会被这道题目给坑了。这道题目的题干如下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二题目&#34;&gt;二、题目&lt;/h3&gt;
&lt;h5 id=&#34;问题&#34;&gt;问题&lt;/h5&gt;
&lt;p&gt;下面这段代码的输出结果是什么？&lt;/p&gt;
&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;
&lt;p&gt;&lt;img alt=&#34;1.png&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2025/02/15/e5ZIlU7w1TRamxi.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;三正确答案&#34;&gt;三、正确答案&lt;/h3&gt;
&lt;h5 id=&#34;输出结果&#34;&gt;输出结果&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;null
I am null
child
I am child
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;四提示&#34;&gt;四、提示&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们将这道题目的代码稍微修改一下&lt;/li&gt;
&lt;li&gt;&lt;img alt=&#34;2.png&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2025/02/15/z25KWc3sH6xFOgI.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;这样修改以后输出结果依然不变&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;五解析&#34;&gt;五、解析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果你的结果和答案一样的话，那么恭喜你，你的Java基础已经是相当扎实的了。如果看完提示后恍然大悟或者半恍然大悟或者完全没明白的话，那么请继续往下看。&lt;/li&gt;
&lt;li&gt;前两个结果竟然是null，这&amp;hellip;&amp;hellip;有点意外。&lt;/li&gt;
&lt;li&gt;其实这道题考察的知识点是继承、重写、对象创建顺序等。&lt;/li&gt;
&lt;li&gt;修改了父类中的俩方法之后输出结果不变。明显的，父类中的方法根本没有执行过。&lt;/li&gt;
&lt;li&gt;那么线索有了，就是方法重写。&lt;/li&gt;
&lt;li&gt;我们知道，当我们执行new Child()的时候，会先执行父类的构造方法，然后再执行子类的构造方法，也就是相当于在子类构造方法的第一行有一个隐藏的super(); 这是Java对象创建的顺序。&lt;/li&gt;
&lt;li&gt;在提示中，我们将子类中的两个方法输出的内容改变了，但是运行结果依旧是和原来一样，这说明父类的构造方法调用的方法其实执行的也是子类中重写过的方法，这个知识点有点隐秘，可能很多人没有注意到。&lt;/li&gt;
&lt;li&gt;接下来我们来写一个小例子&lt;/li&gt;
&lt;li&gt;&lt;img alt=&#34;4.png&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2025/02/15/2J75H1Q9fqGedW6.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;这个例子的输出结果是
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;giao2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;这个例子的意思是，父类中有一个方法，子类中也有一个方法，子类中的方法重写了父类中的方法，然后在父类的构造方法中调用了这个方法，这个时候执行的是子类中的方法，而不是父类中的方法。&lt;/li&gt;
&lt;li&gt;父类的成员方法从头到尾没执行过的问题解开了，接下来我们来看一下，为什么输出的前两个值是null，后两个值是child。&lt;/li&gt;
&lt;li&gt;最使我们疑惑的问题其实是：明明这个值在父类和子类中都分别定义了，并且赋初始值了，为什么还会出现null呢？&lt;/li&gt;
&lt;li&gt;我们再对代码进行两次改动&lt;/li&gt;
&lt;li&gt;&lt;img alt=&#34;5.png&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2025/02/15/UAiEBSpdVngs7Dx.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt=&#34;6.png&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2025/02/15/EtDIeOvsBPKmM7r.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;在这两次改动后输出结果分别为
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//第一次输出结果
parent
I am parent
parent
I am parent
//第二次输出结果
null
I am null
child
I am child
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;这两次改动的变化就是访问的属性不一样，我们惊奇的发现使用super修饰的属性拿到值了，而使用this修饰的属性还是null。这说明了两个情况，一个情况是默认情况下的修饰符是this，另一个情况是super里面的属性有，而this里面的属性没有。&lt;/li&gt;
&lt;li&gt;那么我们再来看一下，为什么会出现这种情况呢？&lt;/li&gt;
&lt;li&gt;我们知道，当我们执行new Child()的时候，会先执行父类的构造方法，然后再执行子类的构造方法，也就是相当于在子类构造方法的第一行有一个隐藏的super(); 这是Java对象创建的顺序。&lt;/li&gt;
&lt;li&gt;哎？这句话刚才是不是说过了？没错，这句话是刚才说过的，但是这句话的重要性不容忽视，这句话的意思是，当我们执行new Child()的时候&amp;hellip;&lt;/li&gt;
&lt;li&gt;扪心自问，正常情况下，咱们会想到类创建顺序的问题吗，答案是肯定的，会的，我们背的都是：先执行父类构造，构造父类对象&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;li&gt;创建子类对象的时候调用父类对象的构造的时候，在父类构造还没执行完的阶段，子类对象会存在吗？答案是否定的，不会存在。我们看下面这个例子。&lt;/li&gt;
&lt;li&gt;&lt;img alt=&#34;7.png&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2025/02/15/ODdkiZzCMU1R63r.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;这段代码的执行结果为0，证明了子类对象在父类构造方法还没执行完的时候是不存在的。&lt;/li&gt;
&lt;li&gt;因为子类对象还没创建出来，所以子类对象的属性也就不存在了，所以使用this修饰的属性是null。&lt;/li&gt;
&lt;li&gt;至此，这道“简短”的面试题也就解析完了，真的是有点小复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;六难点&#34;&gt;六、难点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img alt=&#34;3.png&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2025/02/15/d8k67cq5eJvWSKQ.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt=&#34;8.png&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2025/02/15/Z1cfogCOqbpTeds.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;七看代码&#34;&gt;七、看代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;题目代码：&lt;a href=&#34;https://github.com/tyza66/RandomMeasurement/blob/main/Java/src/main/java/org/example/ParentClassSubclassWhoComesFirstAndWhoComesLater.java&#34;&gt;查看&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;验证重写执行代码：&lt;a href=&#34;https://github.com/tyza66/RandomMeasurement/blob/main/Java/src/main/java/org/example/ParentClassConstructionWillExecuteMethodsOverriddenInSubclasses.java&#34;&gt;查看&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;验证实例化顺序代码：&lt;a href=&#34;https://github.com/tyza66/RandomMeasurement/blob/main/Java/src/main/java/org/example/DoSubclassObjectsExist.java&#34;&gt;查看&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;八总结&#34;&gt;八、总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;小题虽复杂，但也不算难，考验对知识点的掌握和看代码的深度（有时候需要多想）。&lt;/li&gt;
&lt;li&gt;感谢您能耐心看完这篇文章，如果有什么问题，欢迎在评论区留言，我会尽快回复。&lt;/li&gt;
&lt;li&gt;如果您觉得写的还不错，欢迎关注、点赞、分享、订阅、Star，您的点赞是我写作的动力。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
